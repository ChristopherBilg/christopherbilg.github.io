<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Christopher Bilger's Portfolio" />
    <meta name="keywords" content="Resume, Portfolio, Personal, Blog" />
    <meta name="author" content="Christopher Bilger" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Victoria Bilger | Love Letters</title>
    <link rel="icon" type="image/x-icon" href="../images/favicon.ico" />
    <link rel="stylesheet" media="screen" href="../css/mvp.css" />
    <link rel="stylesheet" media="screen" href="../css/styles.css" />
  </head>

  <body>
    <header>
      <div class="typewriter">
        <h1>Victoria Bilger | Love Letters</h1>
      </div>
    </header>

    <main hidden></main>

    <footer>
      <hr />

      <section>
        <h3>Love letters for Victoria Bilger's eyes only.</h3>
      </section>
    </footer>

    <script type="module">
      import * as Arlo from "../js/arlo/index.js";

      for (const exportedName in Arlo) {
        window[exportedName] = Arlo[exportedName];
      }

      (() => {
        document.getElementsByTagName("main")[0].hidden = false;

        class App extends StyledComponent {
          init() {
            this.encoder = new TextEncoder();
            this.decoder = new TextDecoder();

            this.password = prompt("What is the password?");

            this.cipherTextLetters =
              "6X4JAE9sdHhJ/RCH4iteSBCu0Rbou8S6Jv7A/NC35JqKlb1yZMsJD3x2PoZr15wJf6SoBhrRP/Hf+MHgqKiTw+uw1spQTp35+TeMPp33Fb4ychVrOm1c4mGj8fM/nwKHQBxHxNXJ8Ih6y7OtfboBX252T6K3NyWPEQNwy8XAS4YiDoQ+9/jQQCJKP2BLBR79t2gqlGAGJSHhHEuYzEs+pLO0SlM06Pjl9hLL2GCqZZglcfbEpHKQIcG2PnxlctcQof2oycU4hoVOUnO3uD4IXJhuH80OMEw+zzCLP39lZEwDchsoKF503BnbunWCa9NbJo7mUtFd+4Zd+lyYjkbu1A+cOXSTDxrUSib8LYISZj7ViIYqVE8Y8eR+HS5caa097vTGPFHO2dUSNUg+SD9LDR8213p8FScNxVW4R1je2S3cl+UL36WNwqFLyyDAfC7Mn9Yr3SzRDv+x3wqV7cCD0pSB+JN29Z54v8b4PUAG/sYzVoJ3xL73i4kZPyhPtm6A+VswQ05VYllRQYIKHjzQcmRNms1V0tBov/o916bon02HgPU8z3rTiQ1Jt1f3z/F5eOhxr1xxys3r67gchwAgVGXa4Ahc06ndT7eIY8doEBmce2b06xDu9Kh5xsuTb/Gs3BP1pqlB4PHsv0oReKdSZ8yQNCVXtXfDR5drftugZFI2TrTa4FBGDBz2L0u0MBi66rcfoFjjNnt+SyBAjj3FngUCOPDWTNqA1n+9lGdIIfohOd17+Qwz23+dgnmzgr2Vltt4s5vgmElohTjjbXsF";

            this.decrypted = [];
            this.decryptData(this.cipherTextLetters, this.password)
              .then((plaintextString) => {
                this.decrypted = JSON.parse(plaintextString);
                console.log("Decrypted Data:", this.decrypted);
                this.render();

                return this.encryptData(JSON.stringify(this.decrypted), this.password);
              })
              .then((ciphertextString) => console.log(ciphertextString))
              .catch((error) => console.error(error));
          }

          bufferToBase64(buffer) {
            return btoa(new Uint8Array(buffer).reduce((data, byte) => data + String.fromCharCode(byte), ""));
          }

          base64ToBuffer(base64) {
            return Uint8Array.from(atob(base64), (c) => c.charCodeAt(null));
          }

          getPasswordKey(password) {
            return window.crypto.subtle.importKey("raw", this.encoder.encode(password), "PBKDF2", false, ["deriveKey"]);
          }

          deriveKey(passwordKey, salt, keyUsage) {
            return window.crypto.subtle.deriveKey(
              {
                name: "PBKDF2",
                salt: salt,
                iterations: 250000,
                hash: "SHA-256",
              },
              passwordKey,
              { name: "AES-GCM", length: 256 },
              false,
              keyUsage
            );
          }

          async encryptData(plaintext, password) {
            try {
              const salt = window.crypto.getRandomValues(new Uint8Array(16));
              const iv = window.crypto.getRandomValues(new Uint8Array(12));
              const passwordKey = await this.getPasswordKey(password);
              const aesKey = await this.deriveKey(passwordKey, salt, ["encrypt"]);
              const encryptedData = await window.crypto.subtle.encrypt(
                {
                  name: "AES-GCM",
                  iv: iv,
                },
                aesKey,
                this.encoder.encode(plaintext)
              );

              const encryptedDataArray = new Uint8Array(encryptedData);
              let buffer = new Uint8Array(salt.byteLength + iv.byteLength + encryptedDataArray.byteLength);
              buffer.set(salt, 0);
              buffer.set(iv, salt.byteLength);
              buffer.set(encryptedDataArray, salt.byteLength + iv.byteLength);
              return this.bufferToBase64(buffer);
            } catch (e) {
              console.log(`Error - ${e}`);
              return "";
            }
          }

          async decryptData(ciphertext, password) {
            try {
              const encryptedDataBuffer = this.base64ToBuffer(ciphertext);
              const salt = encryptedDataBuffer.slice(0, 16);
              const iv = encryptedDataBuffer.slice(16, 16 + 12);
              const data = encryptedDataBuffer.slice(16 + 12);
              const passwordKey = await this.getPasswordKey(password);
              const aesKey = await this.deriveKey(passwordKey, salt, ["decrypt"]);
              const decryptedData = await window.crypto.subtle.decrypt(
                {
                  name: "AES-GCM",
                  iv: iv,
                },
                aesKey,
                data
              );
              return this.decoder.decode(decryptedData);
            } catch (e) {
              console.log(`Error - ${e}`);
              return "";
            }
          }

          styles() {
            return css`
              div {
                font-family: var(--handwritten-font-family);

                div {
                  display: flex;
                  justify-content: space-between;
                }
              }
            `;
          }

          compose() {
            return vdom`
              <div>
               ${this.decrypted
                 .sort((a, b) => (a.date > b.date ? -1 : 1))
                 .map(
                   (letter, index) => vdom`
                      <div>
                        <hr />

                        <div>
                          <h2>${letter.title}</h2>
                          <h3>${letter.prettyDate}</h3>
                        </div>

                        ${letter.body.map((paragraph) => vdom`<p>${paragraph}</p>`)}
                      </div>
                    `
                 )}
              </div>
            `;
          }
        }

        const app = new App();
        document.getElementsByTagName("main")[0].appendChild(app.node);
      })();
    </script>
  </body>
</html>
