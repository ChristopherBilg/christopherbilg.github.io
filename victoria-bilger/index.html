<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Christopher Bilger's Portfolio" />
    <meta name="keywords" content="Resume, Portfolio, Personal, Blog" />
    <meta name="author" content="Christopher Bilger" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Victoria Bilger | Love Letters</title>
    <link rel="icon" type="image/x-icon" href="../images/favicon.ico" />
    <link rel="stylesheet" media="screen" href="../css/mvp.css" />
    <link rel="stylesheet" media="screen" href="../css/styles.css" />
  </head>

  <body>
    <header>
      <div class="typewriter">
        <h1>Victoria Bilger | Love Letters</h1>
      </div>
    </header>

    <main hidden></main>

    <footer>
      <hr />

      <section>
        <h3>Love letters for Victoria Bilger's eyes only.</h3>
      </section>
    </footer>

    <script type="module">
      import * as Arlo from "../js/arlo/index.js";

      for (const exportedName in Arlo) {
        window[exportedName] = Arlo[exportedName];
      }

      (() => {
        document.getElementsByTagName("main")[0].hidden = false;

        class App extends StyledComponent {
          init() {
            this.encoder = new TextEncoder();
            this.decoder = new TextDecoder();
            this.decrypted = [];

            setTimeout(() => {
              this.password = prompt("What is the password?");

              fetch("./encrypted-data.txt")
                .then((response) => response.text())
                .then((ciphertextString) => this.decryptData(ciphertextString, this.password))
                .then((plaintextString) => {
                  try {
                    this.decrypted = JSON.parse(plaintextString);
                  } catch {}

                  return this.encryptData(JSON.stringify(this.decrypted), this.password);
                })
                .then((ciphertextString) => {
                  console.log("Decrypted Data:", this.decrypted);
                  console.log("Re-encrypted Data:", ciphertextString);

                  this.render();
                })
                .catch((error) => console.error(error));
            }, 2000);
          }

          bufferToBase64(buffer) {
            return btoa(new Uint8Array(buffer).reduce((data, byte) => data + String.fromCharCode(byte), ""));
          }

          base64ToBuffer(base64) {
            return Uint8Array.from(atob(base64), (c) => c.charCodeAt(null));
          }

          getPasswordKey(password) {
            return window.crypto.subtle.importKey("raw", this.encoder.encode(password), "PBKDF2", false, ["deriveKey"]);
          }

          deriveKey(passwordKey, salt, keyUsage) {
            return window.crypto.subtle.deriveKey(
              {
                name: "PBKDF2",
                salt: salt,
                iterations: 250000,
                hash: "SHA-256",
              },
              passwordKey,
              { name: "AES-GCM", length: 256 },
              false,
              keyUsage
            );
          }

          async encryptData(plaintext, password) {
            try {
              const salt = window.crypto.getRandomValues(new Uint8Array(16));
              const iv = window.crypto.getRandomValues(new Uint8Array(12));
              const passwordKey = await this.getPasswordKey(password);
              const aesKey = await this.deriveKey(passwordKey, salt, ["encrypt"]);
              const encryptedData = await window.crypto.subtle.encrypt(
                {
                  name: "AES-GCM",
                  iv: iv,
                },
                aesKey,
                this.encoder.encode(plaintext)
              );

              const encryptedDataArray = new Uint8Array(encryptedData);
              let buffer = new Uint8Array(salt.byteLength + iv.byteLength + encryptedDataArray.byteLength);
              buffer.set(salt, 0);
              buffer.set(iv, salt.byteLength);
              buffer.set(encryptedDataArray, salt.byteLength + iv.byteLength);
              return this.bufferToBase64(buffer);
            } catch (error) {
              console.log(`Error - ${error}`);
              return "";
            }
          }

          async decryptData(ciphertext, password) {
            try {
              const encryptedDataBuffer = this.base64ToBuffer(ciphertext);
              const salt = encryptedDataBuffer.slice(0, 16);
              const iv = encryptedDataBuffer.slice(16, 16 + 12);
              const data = encryptedDataBuffer.slice(16 + 12);
              const passwordKey = await this.getPasswordKey(password);
              const aesKey = await this.deriveKey(passwordKey, salt, ["decrypt"]);
              const decryptedData = await window.crypto.subtle.decrypt(
                {
                  name: "AES-GCM",
                  iv: iv,
                },
                aesKey,
                data
              );
              return this.decoder.decode(decryptedData);
            } catch (error) {
              console.log(`Error - ${error}`);
              return "";
            }
          }

          styles() {
            return css`
              div {
                font-family: var(--handwritten-font-family);

                h2 {
                  text-align: center;
                }

                div {
                  display: flex;
                  justify-content: space-between;
                }
              }
            `;
          }

          compose() {
            return vdom`
              <div>
                ${
                  this.decrypted.length === 0
                    ? vdom`
                      <div>
                        <hr />
                        <h2>Nothing to see here.</h2>
                      </div>
                    `
                    : this.decrypted
                        .sort((a, b) => (a.date > b.date ? -1 : 1))
                        .map(
                          (letter) => vdom`
                            <div>
                              <hr />

                              <div>
                                <h2>${letter.title}</h2>
                                <h3>${letter.prettyDate}</h3>
                              </div>

                              ${letter.body.map((paragraph) => vdom`<p>${paragraph}</p>`)}
                            </div>
                          `
                        )
                }
              </div>
            `;
          }
        }

        const app = new App();
        document.getElementsByTagName("main")[0].appendChild(app.node);
      })();
    </script>
  </body>
</html>
