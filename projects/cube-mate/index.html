<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Christopher Bilger's Portfolio">
    <meta name="keywords" content="Resume, Portfolio, Personal, Blog">
    <meta name="author" content="Christopher Bilger">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Cube Mate (Rubik's Cube Tools)</title>
    <link rel="icon" type="image/x-icon" href="../../images/favicon.ico">
    <link rel="stylesheet" media="screen" href="../../css/mvp.css">
    <link rel="stylesheet" media="screen" href="../../css/styles.css">
</head>

<body>
    <noscript id="full-screen-noscript-message">
        Please enable JavaScript in order to use the password generator.
    </noscript>

    <main hidden>
        <a href="/projects">Back to Projects List</a>

        <h1>Cube Mate (Rubik's Cube Tools)</h1>

        <p>
            <b>Cube Mate</b> is an extremely minimal set of tools that I am using to learn (at my own pace) efficient
            Rubik's Cube solving methods. If you wish to use better tools, look into the website
            <a href="https://cstimer.net/" target="_blank">cstimer.net &nearr;</a>. No data/information/values/etc. is
            sent away from your local browser instance.
        </p>

        <hr /><br />
        <input type="submit" value="Scramble" onclick="return updateScrambleAndCross();" />
        <h2 id="scramble"></h2>
        <h2 id="cross"></h2>
        <div id="cross-color"></div>

        <br />
        <hr />
        <p><b>Note:</b> Pressing the space key on your keyboard will start and stop the timer.</p>
        <input type="submit" value="Start/Stop Timer" onclick="return toggleTimerRunningState();" />
        <input type="submit" value="Reset Timer" onclick="return resetTimer();" />
        <input type="submit" value="Reset Timer History" onclick="return resetTimerHistory();" />
        <h2 id="timer"></h2>
        <div id="timer-history"></div>
    </main>

    <script>
        document.getElementsByTagName('main')[0].hidden = false;

        const generateRandomScramble = () => {
            const options = ['F', 'F2', 'F\'', 'R', 'R2', 'R\'', 'U', 'U2', 'U\'', 'B', 'B2', 'B\'', 'L', 'L2', 'L\'', 'D', 'D2', 'D\''];
            const numOptions = [0, 1, 2, 3, 4, 5];
            let scramble = [];
            let scrambleMoves = [];
            let bad = true;

            const getRandomInt = max => {
                return Math.floor(Math.random() * Math.floor(max));
            };

            const getRandomIntBetween = (min, max) => {
                return Math.floor(Math.random() * (max - min) + min);
            };

            while (bad) {
                scramble = [];
                for (var i = 0; i < 20; i++) {
                    scramble.push(numOptions[getRandomInt(6)]);
                }

                for (var i = 0; i < 20 - 1; i++) {
                    if (scramble[i] == scramble[i + 1]) {
                        bad = true;
                        break;
                    } else {
                        bad = false;
                    }
                }
            }

            var move;
            for (var i = 0; i < 20; i++) {
                switch (scramble[i]) {
                    case 0:
                        move = options[getRandomInt(3)];
                        scrambleMoves.push(move);
                        break;
                    case 1:
                        move = options[getRandomIntBetween(3, 6)];
                        scrambleMoves.push(move);
                        break;
                    case 2:
                        move = options[getRandomIntBetween(6, 9)];
                        scrambleMoves.push(move);
                        break;
                    case 3:
                        move = options[getRandomIntBetween(9, 12)];
                        scrambleMoves.push(move);
                        break;
                    case 4:
                        move = options[getRandomIntBetween(12, 15)];
                        scrambleMoves.push(move);
                        break;
                    case 5:
                        move = options[getRandomIntBetween(15, 18)];
                        scrambleMoves.push(move);
                        break;
                }
            }

            return scrambleMoves;
        };

        const colors = ['Red', 'Green', 'White', 'Blue', 'Yellow', 'Orange']
        const generateRandomCrossColor = () => {
            return colors[Math.floor(Math.random() * colors.length)];
        };

        const scrambleHTMLElement = document.getElementById('scramble');
        const crossHTMLElement = document.getElementById('cross');
        const crossColorHTMLElement = document.getElementById('cross-color');

        const updateScrambleAndCross = () => {
            const crossColor = generateRandomCrossColor();

            scrambleHTMLElement.innerHTML = `Scramble: ${generateRandomScramble().join(' ')}`;
            crossHTMLElement.innerHTML = `Cross Color: ${crossColor}`;

            crossColorHTMLElement.style.width = '10rem';
            crossColorHTMLElement.style.height = '3rem';
            crossColorHTMLElement.style.backgroundColor = crossColor;
            crossColorHTMLElement.style.border = '2px solid black';

            return false;
        };
        updateScrambleAndCross();

        let timerRunning = false;
        let timerCurrentTime = 0;
        const timerHTMLElement = document.getElementById('timer');

        const loadTimerHistoryFromLocalStorage = () => {
            return JSON.parse(localStorage.getItem('timerHistory'));
        };

        const TIMER_HISTORY_TEMPLATE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let timerHistory = loadTimerHistoryFromLocalStorage() || JSON.parse(JSON.stringify(TIMER_HISTORY_TEMPLATE));

        const saveTimerHistoryToLocalStorage = () => {
            const stringified = JSON.stringify(timerHistory);
            localStorage.setItem('timerHistory', stringified);
        };
        saveTimerHistoryToLocalStorage();

        const convertTimeToHumanReadableString = time => {
            let milliseconds = Math.floor((time % 1000));
            let seconds = Math.floor((time / 1000) % 60);
            let hours = Math.floor((time / (1000 * 60 * 60)) % 24);
            let minutes = Math.floor((time / (1000 * 60)) % 60);

            milliseconds = (milliseconds < 100) ? ((milliseconds < 10) ? '00' + milliseconds : '0' + milliseconds) : milliseconds;
            seconds = (seconds < 10) ? '0' + seconds : seconds;
            minutes = (minutes < 10) ? '0' + minutes : minutes;
            hours = (hours < 10) ? '0' + hours : hours;

            return hours + ':' + minutes + ':' + seconds + '.' + milliseconds;
        };

        const timerHistoryHTMLElement = document.getElementById('timer-history');
        const rerenderTimerHistoryHTMLElements = () => {
            timerHistoryHTMLElement.innerHTML = '';

            const getBestAverageOfN = n => {
                let currentBest = Number.MAX_SAFE_INTEGER;
                for (let i = TIMER_HISTORY_TEMPLATE.length; i <= timerHistory.length - n; i++) {
                    const tempBest = timerHistory.slice(i, i + n).reduce((a, b) => (a + b)) / n;
                    if (tempBest < currentBest) currentBest = tempBest;
                }

                return currentBest;
            };

            const pb = document.createElement('p');
            const tempPB = convertTimeToHumanReadableString(Math.min(...timerHistory.slice(12, timerHistory.length)));
            pb.innerHTML = `PB: ${timerHistory.length >= TIMER_HISTORY_TEMPLATE.length + 1 ? tempPB : convertTimeToHumanReadableString(0)}`;
            timerHistoryHTMLElement.appendChild(pb);

            const currentAo5 = document.createElement('p');
            const tempAo5 = convertTimeToHumanReadableString(timerHistory.slice(-5).reduce((a, b) => (a + b)) / 5);
            currentAo5.innerHTML = `Current Ao5: ${timerHistory.length >= TIMER_HISTORY_TEMPLATE.length + 5 ? tempAo5 : convertTimeToHumanReadableString(0)}`;
            timerHistoryHTMLElement.appendChild(currentAo5);

            const bestAo5 = document.createElement('p');
            const tempBestAo5 = convertTimeToHumanReadableString(getBestAverageOfN(5));
            bestAo5.innerHTML = `Best Ao5: ${timerHistory.length >= TIMER_HISTORY_TEMPLATE.length + 5 ? tempBestAo5 : convertTimeToHumanReadableString(0)}`;
            timerHistoryHTMLElement.appendChild(bestAo5);

            const currentAo12 = document.createElement('p');
            const tempAo12 = convertTimeToHumanReadableString(timerHistory.slice(-12).reduce((a, b) => (a + b)) / 12);
            currentAo12.innerHTML = `Current Ao12: ${timerHistory.length >= TIMER_HISTORY_TEMPLATE.length + 12 ? tempAo12 : convertTimeToHumanReadableString(0)}`;
            timerHistoryHTMLElement.appendChild(currentAo12);

            const bestAo12 = document.createElement('p');
            const tempBestAo12 = convertTimeToHumanReadableString(getBestAverageOfN(12));
            bestAo12.innerHTML = `Best Ao12: ${timerHistory.length >= TIMER_HISTORY_TEMPLATE.length + 12 ? tempBestAo12 : convertTimeToHumanReadableString(0)}`;
            timerHistoryHTMLElement.appendChild(bestAo12);
        };
        rerenderTimerHistoryHTMLElements();

        const addTimeToTimerHistory = time => {
            timerHistory.push(time);
            saveTimerHistoryToLocalStorage();

            rerenderTimerHistoryHTMLElements();
        };

        const toggleTimerRunningState = async () => {
            const sleep = ms => new Promise(r => setTimeout(r, ms));

            if (timerRunning) {
                timerRunning = false;

                addTimeToTimerHistory(timerCurrentTime);
                timerCurrentTime = 0;
            }
            else {
                timerRunning = true;
                const startDate = Date.now();
                let currentDate;

                while (timerRunning) {
                    currentDate = Date.now();
                    timerCurrentTime = currentDate - startDate;

                    timerHTMLElement.innerHTML = convertTimeToHumanReadableString(timerCurrentTime);
                    await sleep(1);
                }
            }
        };
        window.onkeypress = event => {
            if (event.keyCode === 32) {
                event.preventDefault();
                toggleTimerRunningState();
            }
        };

        const resetTimer = () => {
            if (timerRunning) {
                timerRunning = false;
                timerCurrentTime = 0;
            }

            timerHTMLElement.innerHTML = convertTimeToHumanReadableString(timerCurrentTime);
        }
        resetTimer();

        const resetTimerHistory = () => {
            resetTimer();
            timerHistory = JSON.parse(JSON.stringify(TIMER_HISTORY_TEMPLATE));

            saveTimerHistoryToLocalStorage();
            rerenderTimerHistoryHTMLElements();
        };
    </script>
</body>

</html>