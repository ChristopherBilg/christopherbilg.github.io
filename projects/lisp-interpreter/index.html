<!DOCTYPE html>
<html lang="en" color-mode="user">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Christopher Bilger's Portfolio" />
    <meta name="keywords" content="Resume, Portfolio, Personal, Projects, Presentations" />
    <meta name="author" content="Christopher Bilger" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Lisp Interpreter</title>
    <link rel="icon" type="image/x-icon" href="../../images/favicon.ico" />
    <link rel="stylesheet" media="screen" href="../../css/mvp.css" />
    <link rel="stylesheet" media="screen" href="../../css/styles.css" />
  </head>

  <body>
    <noscript id="full-screen-noscript-message">Please enable JavaScript in order to view this webpage.</noscript>

    <main hidden>
      <a href="/projects">Back to Projects List</a>

      <h1>Lisp Interpreter</h1>

      <p>
        A full-featured Lisp interpreter implemented in JavaScript using proper design patterns. Features include
        lexical scoping, closures, macros, tail call optimization, and a Foreign Function Interface for browser interop.
      </p>

      <div id="repl-container"></div>
    </main>

    <script type="module">
      import * as Arlo from "../../js/arlo/index.js";
      import { Evaluator } from "./lisp/evaluator.js";
      import { Parser } from "./lisp/parser.js";
      import { stringify } from "./lisp/environment.js";
      import * as ffi from "./lisp/ffi.js";

      for (const exportedName in Arlo) {
        window[exportedName] = Arlo[exportedName];
      }

      (() => {
        document.getElementsByTagName("main")[0].hidden = false;

        // History entry model
        class HistoryEntry extends Record {
          constructor(type, content) {
            super({ type, content, timestamp: Date.now() });
          }
        }

        // REPL Store to manage history
        class ReplStore extends Store {
          constructor() {
            super();
            this.history = [];
            this.commandHistory = [];
            this.historyIndex = -1;
          }

          addEntry(type, content) {
            const entry = new HistoryEntry(type, content);
            this.history.push(entry);
            this.emitEvent();
            return entry;
          }

          addCommand(command) {
            if (command.trim()) {
              this.commandHistory.push(command);
              this.historyIndex = this.commandHistory.length;
            }
          }

          getPreviousCommand() {
            if (this.historyIndex > 0) {
              this.historyIndex--;
              return this.commandHistory[this.historyIndex];
            }
            return this.commandHistory[0] || "";
          }

          getNextCommand() {
            if (this.historyIndex < this.commandHistory.length - 1) {
              this.historyIndex++;
              return this.commandHistory[this.historyIndex];
            }
            this.historyIndex = this.commandHistory.length;
            return "";
          }

          clear() {
            this.history = [];
            this.emitEvent();
          }

          getHistory() {
            return this.history;
          }
        }

        // History Entry Component
        class HistoryEntryComponent extends StyledComponent {
          init(entry) {
            this.entry = entry;
          }

          styles() {
            const baseStyles = {
              "font-family": "'Fira Code', 'Consolas', 'Monaco', monospace",
              "font-size": "14px",
              padding: "8px 12px",
              margin: "4px 0",
              "border-radius": "4px",
              "white-space": "pre-wrap",
              "word-break": "break-word",
              "line-height": "1.4",
            };

            const typeStyles = {
              input: {
                ...baseStyles,
                "background-color": "#2d2d2d",
                color: "#88c0d0",
                "border-left": "3px solid #88c0d0",
              },
              output: {
                ...baseStyles,
                "background-color": "#1e1e1e",
                color: "#a3be8c",
                "border-left": "3px solid #a3be8c",
              },
              error: {
                ...baseStyles,
                "background-color": "#2d1f1f",
                color: "#bf616a",
                "border-left": "3px solid #bf616a",
              },
              info: {
                ...baseStyles,
                "background-color": "#1f2d2d",
                color: "#b48ead",
                "border-left": "3px solid #b48ead",
              },
            };

            return typeStyles[this.entry.data.type] || baseStyles;
          }

          compose() {
            const { type, content } = this.entry.data;
            const prefix = type === "input" ? "> " : type === "error" ? "Error: " : "";
            return vdom`<div>${prefix}${content}</div>`;
          }
        }

        // Main REPL Component
        class ReplComponent extends StyledComponent {
          init() {
            this.store = new ReplStore();
            this.evaluator = null;
            this.inputValue = "";

            // Initialize evaluator with FFI
            this.initEvaluator();

            // Bind to store updates
            this.bind(this.store, () => this.render());
          }

          async initEvaluator() {
            // Create evaluator with custom output function
            this.evaluator = new Evaluator({
              output: (msg) => {
                this.store.addEntry("output", String(msg));
              },
            });

            // Register FFI functions
            this.evaluator.registerFFI(ffi);

            // Add welcome message
            this.store.addEntry(
              "info",
              "Welcome to the Lisp REPL!\n" +
                "Type Lisp expressions and press Enter to evaluate.\n" +
                "Use Up/Down arrows to navigate command history.\n" +
                "Type (help) for available functions."
            );

            // Define help function
            try {
              this.evaluator.eval(
                Parser.parse(`
                (define (help)
                  (display "Available special forms:")
                  (display "  define, lambda, if, cond, let, let*, letrec, begin, and, or, quote, quasiquote, define-macro")
                  (newline)
                  (display "Arithmetic: +, -, *, /, modulo, abs, sqrt, expt, sin, cos, tan, log, exp")
                  (display "Comparison: =, <, >, <=, >=, eq?, equal?")
                  (display "Lists: cons, car, cdr, list, append, length, map, filter, reduce")
                  (display "Strings: string-append, string-length, substring, string-split")
                  (display "I/O: display, print, newline")
                  (newline)
                  (display "FFI (JavaScript interop):")
                  (display "  js-global, js-get, js-set!, js-call, js-new")
                  (display "  query-selector, create-element, set-style!, add-event-listener!")
                  (newline)
                  (display "Examples:")
                  (display "  (+ 1 2 3)")
                  (display "  (define square (lambda (x) (* x x)))")
                  (display "  (map (lambda (x) (* x 2)) '(1 2 3 4))")
                  (display "  (query-selector \\"body\\")")
                  nil)
              `)
              );
            } catch (e) {
              console.error("Error defining help:", e);
            }

            // Run example: efficient tail-recursive Fibonacci
            this.runExample(
              `(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        a
        (fib-iter b (+ a b) (- count 1))))
  (fib-iter 0 1 n))`
            );
            this.runExample("(fib 100)");

            this.render();
          }

          runExample(code) {
            // Add input to history display (as if user typed it)
            this.store.addEntry("input", code);
            this.store.addCommand(code);

            // Evaluate
            try {
              const ast = Parser.parse(code);
              const result = this.evaluator.eval(ast);

              // Only show result if it's not null
              if (result !== null) {
                this.store.addEntry("output", stringify(result));
              }
            } catch (e) {
              this.store.addEntry("error", e.message);
            }
          }

          styles() {
            return {
              display: "flex",
              "flex-direction": "column",
              "background-color": "#1a1a1a",
              "border-radius": "8px",
              border: "1px solid #333",
              overflow: "hidden",
              "font-family": "'Fira Code', 'Consolas', 'Monaco', monospace",
              "max-width": "100%",
              "min-height": "500px",

              ".repl-header": {
                display: "flex",
                "justify-content": "space-between",
                "align-items": "center",
                padding: "12px 16px",
                "background-color": "#2d2d2d",
                "border-bottom": "1px solid #333",
              },

              ".repl-title": {
                color: "#88c0d0",
                "font-size": "14px",
                "font-weight": "bold",
              },

              ".repl-clear-btn": {
                background: "#4c566a",
                color: "#eceff4",
                border: "none",
                padding: "6px 12px",
                "border-radius": "4px",
                cursor: "pointer",
                "font-size": "12px",
                "font-family": "inherit",
                "&:hover": {
                  background: "#5e81ac",
                },
              },

              ".repl-output": {
                flex: "1",
                "overflow-y": "auto",
                padding: "12px",
                "max-height": "400px",
                "min-height": "300px",
              },

              ".repl-input-container": {
                display: "flex",
                "align-items": "center",
                padding: "12px",
                "background-color": "#2d2d2d",
                "border-top": "1px solid #333",
              },

              ".repl-prompt": {
                color: "#88c0d0",
                "margin-right": "8px",
                "font-size": "14px",
                "user-select": "none",
              },

              ".repl-input": {
                flex: "1",
                background: "transparent",
                border: "none",
                color: "#eceff4",
                "font-family": "inherit",
                "font-size": "14px",
                outline: "none",
                "&::placeholder": {
                  color: "#4c566a",
                },
              },

              ".repl-submit-btn": {
                background: "#5e81ac",
                color: "#eceff4",
                border: "none",
                padding: "8px 16px",
                "border-radius": "4px",
                cursor: "pointer",
                "font-size": "12px",
                "font-family": "inherit",
                "margin-left": "8px",
                "&:hover": {
                  background: "#81a1c1",
                },
              },
            };
          }

          handleInput(e) {
            this.inputValue = e.target.value;
          }

          handleKeyDown(e) {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              this.evaluate();
            } else if (e.key === "ArrowUp") {
              e.preventDefault();
              const prev = this.store.getPreviousCommand();
              if (prev !== undefined) {
                this.inputValue = prev;
                e.target.value = prev;
              }
            } else if (e.key === "ArrowDown") {
              e.preventDefault();
              const next = this.store.getNextCommand();
              this.inputValue = next;
              e.target.value = next;
            }
          }

          evaluate() {
            const input = this.inputValue.trim();
            if (!input) return;

            // Add input to history
            this.store.addEntry("input", input);
            this.store.addCommand(input);

            // Clear input
            this.inputValue = "";
            const inputEl = this.node.querySelector(".repl-input");
            if (inputEl) inputEl.value = "";

            // Evaluate
            try {
              const ast = Parser.parse(input);
              const result = this.evaluator.eval(ast);

              // Only show result if it's not null (display/print return null)
              if (result !== null) {
                this.store.addEntry("output", stringify(result));
              }
            } catch (e) {
              this.store.addEntry("error", e.message);
            }

            // Scroll to bottom
            requestAnimationFrame(() => {
              const output = this.node.querySelector(".repl-output");
              if (output) output.scrollTop = output.scrollHeight;
            });
          }

          clearHistory() {
            this.store.clear();
            this.store.addEntry("info", "REPL cleared. Type (help) for available functions.");
          }

          compose() {
            const history = this.store.getHistory();
            const historyComponents = history.map((entry) => new HistoryEntryComponent(entry).node);

            return vdom`
              <div>
                <div class="repl-header">
                  <span class="repl-title">Lisp REPL</span>
                  <button
                    class="repl-clear-btn"
                    onclick=${() => this.clearHistory()}
                  >Clear</button>
                </div>

                <div class="repl-output">
                  ${historyComponents}
                </div>

                <div class="repl-input-container">
                  <span class="repl-prompt">></span>
                  <input
                    type="text"
                    class="repl-input"
                    placeholder="Enter Lisp expression..."
                    oninput=${(e) => this.handleInput(e)}
                    onkeydown=${(e) => this.handleKeyDown(e)}
                    autocomplete="off"
                    spellcheck="false"
                  />
                  <button
                    class="repl-submit-btn"
                    onclick=${() => this.evaluate()}
                  >Eval</button>
                </div>
              </div>
            `;
          }
        }

        // Mount the REPL
        const repl = new ReplComponent();
        document.getElementById("repl-container").appendChild(repl.node);
      })();
    </script>
  </body>
</html>
